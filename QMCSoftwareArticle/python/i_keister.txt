>>> d = 2
>>> def my_Keister(x): # create a custom function
...     norm = np.sqrt((x**2).sum(1))
...     out = np.pi**(d/2)*np.cos(norm)
...     return out # x is (nxd), out is a length-n vector
>>> kqp = qp.CustomFun(
...     discrete_distrib = qp.Halton(d),
...     g = my_Keister,
...     true_measure = qp.Gaussian(d,mean=0,covariance=1/2))
>>> x = kqp.discrete_distrib.gen_samples(1000) # Halton points
>>> y = kqp.f(x) # evaluate transformed integrand
>>> y.mean() # approximate the integral
1.808459727813744
